%Здесь мы записываем значения наших величин
load('L11.mat')
load('T11.mat')
load('R11.mat')
% L11 вектор составелнный из значений длина волны
% T11 вектор составелнный из значений коэфициента пропускания
% R11 вектор составелнный из значений коэфициента отражения
T=T11;
R=R11;
L=L11;
ln=length(R11); % размер вектора R11
d = 3*10^(-1); % считаем в сантиметрах
Pi=(4*(pi)); 
i=0;%необходима для сохранения ответов в памяти матлаба
%Исходня формула для поиска r : T^2-(R-r)^2-(1-r)^2*((R/r)-1)==0
for m=1:1:ln % Очевидно,что ln соответсвует числу точек 
    syms r1
        assume(r1,'real')
eqn_r =(T(m))^2-(R(m))^2+3*R(m)*r1-2*(r1)^2-(R(m)/r1)+1==0;
    r = vpasolve(eqn_r,r1,[0,Inf]); % Видим 2 корня (т.к. уравнение
                                    % квадратное относительно r)
                                    %берём корень меньший R(m).
    % ОТБОР КОРНЕЙ r
        if r(1)<r(2)
            if r(2)<R11(m)
                r = r(2);
            else
                r = r(1);
            end
        end
    % Найдём альфу
 alfa = -(1/d)*log((R(m)-r)/(r*T(m)));
    
     %ВЫЧИСЛЯЕМ к
 k = (alfa*L(m))/Pi;
   
     % ВЫЧИСЛЯЕМ n
      syms n1
        assume(n1,'real')
 eqnN =(1-r)*n1^2-2*n1*(1+r)+(1-r)*(k^2+1)==0;
 n = vpasolve(eqnN,n1,1);
        
     % ОТБОР КОРНЕЙ n
        if n(1)>n(2)
            n=n(1);
        else
            n=n(2);
        end
    i=i+1; % Счётчик для сохранения ответов в соотвестующих векторах ,
           % содержащих значения n и alfa
    N(i)=double(n);
    Alfa2(i)=double(alfa);
end
TableReflativeIndex = transpose(N);% Здесь получается столбец значений 
                                  % показателя преломления
TableAlfa  = transpose(Alfa2); % Здесь получается столбец значений альфы

